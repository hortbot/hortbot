// Code generated by SQLBoiler v4.13.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// Channel is an object representing the database table.
type Channel struct {
	ID                          int64             `boil:"id" json:"id" toml:"id" yaml:"id"`
	CreatedAt                   time.Time         `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt                   time.Time         `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	TwitchID                    int64             `boil:"twitch_id" json:"twitch_id" toml:"twitch_id" yaml:"twitch_id"`
	Name                        string            `boil:"name" json:"name" toml:"name" yaml:"name"`
	DisplayName                 string            `boil:"display_name" json:"display_name" toml:"display_name" yaml:"display_name"`
	BotName                     string            `boil:"bot_name" json:"bot_name" toml:"bot_name" yaml:"bot_name"`
	Active                      bool              `boil:"active" json:"active" toml:"active" yaml:"active"`
	Prefix                      string            `boil:"prefix" json:"prefix" toml:"prefix" yaml:"prefix"`
	Bullet                      null.String       `boil:"bullet" json:"bullet,omitempty" toml:"bullet" yaml:"bullet,omitempty"`
	MessageCount                int64             `boil:"message_count" json:"message_count" toml:"message_count" yaml:"message_count"`
	Mode                        string            `boil:"mode" json:"mode" toml:"mode" yaml:"mode"`
	Ignored                     types.StringArray `boil:"ignored" json:"ignored" toml:"ignored" yaml:"ignored"`
	CustomOwners                types.StringArray `boil:"custom_owners" json:"custom_owners" toml:"custom_owners" yaml:"custom_owners"`
	CustomMods                  types.StringArray `boil:"custom_mods" json:"custom_mods" toml:"custom_mods" yaml:"custom_mods"`
	CustomRegulars              types.StringArray `boil:"custom_regulars" json:"custom_regulars" toml:"custom_regulars" yaml:"custom_regulars"`
	Cooldown                    null.Int          `boil:"cooldown" json:"cooldown,omitempty" toml:"cooldown" yaml:"cooldown,omitempty"`
	LastFM                      string            `boil:"last_fm" json:"last_fm" toml:"last_fm" yaml:"last_fm"`
	ParseYoutube                bool              `boil:"parse_youtube" json:"parse_youtube" toml:"parse_youtube" yaml:"parse_youtube"`
	ExtraLifeID                 int               `boil:"extra_life_id" json:"extra_life_id" toml:"extra_life_id" yaml:"extra_life_id"`
	RaffleEnabled               bool              `boil:"raffle_enabled" json:"raffle_enabled" toml:"raffle_enabled" yaml:"raffle_enabled"`
	SteamID                     string            `boil:"steam_id" json:"steam_id" toml:"steam_id" yaml:"steam_id"`
	UrbanEnabled                bool              `boil:"urban_enabled" json:"urban_enabled" toml:"urban_enabled" yaml:"urban_enabled"`
	Tweet                       string            `boil:"tweet" json:"tweet" toml:"tweet" yaml:"tweet"`
	RollLevel                   string            `boil:"roll_level" json:"roll_level" toml:"roll_level" yaml:"roll_level"`
	RollCooldown                int               `boil:"roll_cooldown" json:"roll_cooldown" toml:"roll_cooldown" yaml:"roll_cooldown"`
	RollDefault                 int               `boil:"roll_default" json:"roll_default" toml:"roll_default" yaml:"roll_default"`
	ShouldModerate              bool              `boil:"should_moderate" json:"should_moderate" toml:"should_moderate" yaml:"should_moderate"`
	DisplayWarnings             bool              `boil:"display_warnings" json:"display_warnings" toml:"display_warnings" yaml:"display_warnings"`
	EnableWarnings              bool              `boil:"enable_warnings" json:"enable_warnings" toml:"enable_warnings" yaml:"enable_warnings"`
	TimeoutDuration             int               `boil:"timeout_duration" json:"timeout_duration" toml:"timeout_duration" yaml:"timeout_duration"`
	EnableFilters               bool              `boil:"enable_filters" json:"enable_filters" toml:"enable_filters" yaml:"enable_filters"`
	FilterLinks                 bool              `boil:"filter_links" json:"filter_links" toml:"filter_links" yaml:"filter_links"`
	PermittedLinks              types.StringArray `boil:"permitted_links" json:"permitted_links" toml:"permitted_links" yaml:"permitted_links"`
	SubsMayLink                 bool              `boil:"subs_may_link" json:"subs_may_link" toml:"subs_may_link" yaml:"subs_may_link"`
	FilterCaps                  bool              `boil:"filter_caps" json:"filter_caps" toml:"filter_caps" yaml:"filter_caps"`
	FilterCapsMinChars          int               `boil:"filter_caps_min_chars" json:"filter_caps_min_chars" toml:"filter_caps_min_chars" yaml:"filter_caps_min_chars"`
	FilterCapsPercentage        int               `boil:"filter_caps_percentage" json:"filter_caps_percentage" toml:"filter_caps_percentage" yaml:"filter_caps_percentage"`
	FilterCapsMinCaps           int               `boil:"filter_caps_min_caps" json:"filter_caps_min_caps" toml:"filter_caps_min_caps" yaml:"filter_caps_min_caps"`
	FilterEmotes                bool              `boil:"filter_emotes" json:"filter_emotes" toml:"filter_emotes" yaml:"filter_emotes"`
	FilterEmotesMax             int               `boil:"filter_emotes_max" json:"filter_emotes_max" toml:"filter_emotes_max" yaml:"filter_emotes_max"`
	FilterEmotesSingle          bool              `boil:"filter_emotes_single" json:"filter_emotes_single" toml:"filter_emotes_single" yaml:"filter_emotes_single"`
	FilterSymbols               bool              `boil:"filter_symbols" json:"filter_symbols" toml:"filter_symbols" yaml:"filter_symbols"`
	FilterSymbolsPercentage     int               `boil:"filter_symbols_percentage" json:"filter_symbols_percentage" toml:"filter_symbols_percentage" yaml:"filter_symbols_percentage"`
	FilterSymbolsMinSymbols     int               `boil:"filter_symbols_min_symbols" json:"filter_symbols_min_symbols" toml:"filter_symbols_min_symbols" yaml:"filter_symbols_min_symbols"`
	FilterMe                    bool              `boil:"filter_me" json:"filter_me" toml:"filter_me" yaml:"filter_me"`
	FilterMaxLength             int               `boil:"filter_max_length" json:"filter_max_length" toml:"filter_max_length" yaml:"filter_max_length"`
	FilterBannedPhrases         bool              `boil:"filter_banned_phrases" json:"filter_banned_phrases" toml:"filter_banned_phrases" yaml:"filter_banned_phrases"`
	FilterBannedPhrasesPatterns types.StringArray `boil:"filter_banned_phrases_patterns" json:"filter_banned_phrases_patterns" toml:"filter_banned_phrases_patterns" yaml:"filter_banned_phrases_patterns"`
	SubMessage                  string            `boil:"sub_message" json:"sub_message" toml:"sub_message" yaml:"sub_message"`
	SubMessageEnabled           bool              `boil:"sub_message_enabled" json:"sub_message_enabled" toml:"sub_message_enabled" yaml:"sub_message_enabled"`
	ResubMessage                string            `boil:"resub_message" json:"resub_message" toml:"resub_message" yaml:"resub_message"`
	ResubMessageEnabled         bool              `boil:"resub_message_enabled" json:"resub_message_enabled" toml:"resub_message_enabled" yaml:"resub_message_enabled"`
	LastSeen                    time.Time         `boil:"last_seen" json:"last_seen" toml:"last_seen" yaml:"last_seen"`
	FilterExemptLevel           string            `boil:"filter_exempt_level" json:"filter_exempt_level" toml:"filter_exempt_level" yaml:"filter_exempt_level"`

	R *channelR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L channelL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ChannelColumns = struct {
	ID                          string
	CreatedAt                   string
	UpdatedAt                   string
	TwitchID                    string
	Name                        string
	DisplayName                 string
	BotName                     string
	Active                      string
	Prefix                      string
	Bullet                      string
	MessageCount                string
	Mode                        string
	Ignored                     string
	CustomOwners                string
	CustomMods                  string
	CustomRegulars              string
	Cooldown                    string
	LastFM                      string
	ParseYoutube                string
	ExtraLifeID                 string
	RaffleEnabled               string
	SteamID                     string
	UrbanEnabled                string
	Tweet                       string
	RollLevel                   string
	RollCooldown                string
	RollDefault                 string
	ShouldModerate              string
	DisplayWarnings             string
	EnableWarnings              string
	TimeoutDuration             string
	EnableFilters               string
	FilterLinks                 string
	PermittedLinks              string
	SubsMayLink                 string
	FilterCaps                  string
	FilterCapsMinChars          string
	FilterCapsPercentage        string
	FilterCapsMinCaps           string
	FilterEmotes                string
	FilterEmotesMax             string
	FilterEmotesSingle          string
	FilterSymbols               string
	FilterSymbolsPercentage     string
	FilterSymbolsMinSymbols     string
	FilterMe                    string
	FilterMaxLength             string
	FilterBannedPhrases         string
	FilterBannedPhrasesPatterns string
	SubMessage                  string
	SubMessageEnabled           string
	ResubMessage                string
	ResubMessageEnabled         string
	LastSeen                    string
	FilterExemptLevel           string
}{
	ID:                          "id",
	CreatedAt:                   "created_at",
	UpdatedAt:                   "updated_at",
	TwitchID:                    "twitch_id",
	Name:                        "name",
	DisplayName:                 "display_name",
	BotName:                     "bot_name",
	Active:                      "active",
	Prefix:                      "prefix",
	Bullet:                      "bullet",
	MessageCount:                "message_count",
	Mode:                        "mode",
	Ignored:                     "ignored",
	CustomOwners:                "custom_owners",
	CustomMods:                  "custom_mods",
	CustomRegulars:              "custom_regulars",
	Cooldown:                    "cooldown",
	LastFM:                      "last_fm",
	ParseYoutube:                "parse_youtube",
	ExtraLifeID:                 "extra_life_id",
	RaffleEnabled:               "raffle_enabled",
	SteamID:                     "steam_id",
	UrbanEnabled:                "urban_enabled",
	Tweet:                       "tweet",
	RollLevel:                   "roll_level",
	RollCooldown:                "roll_cooldown",
	RollDefault:                 "roll_default",
	ShouldModerate:              "should_moderate",
	DisplayWarnings:             "display_warnings",
	EnableWarnings:              "enable_warnings",
	TimeoutDuration:             "timeout_duration",
	EnableFilters:               "enable_filters",
	FilterLinks:                 "filter_links",
	PermittedLinks:              "permitted_links",
	SubsMayLink:                 "subs_may_link",
	FilterCaps:                  "filter_caps",
	FilterCapsMinChars:          "filter_caps_min_chars",
	FilterCapsPercentage:        "filter_caps_percentage",
	FilterCapsMinCaps:           "filter_caps_min_caps",
	FilterEmotes:                "filter_emotes",
	FilterEmotesMax:             "filter_emotes_max",
	FilterEmotesSingle:          "filter_emotes_single",
	FilterSymbols:               "filter_symbols",
	FilterSymbolsPercentage:     "filter_symbols_percentage",
	FilterSymbolsMinSymbols:     "filter_symbols_min_symbols",
	FilterMe:                    "filter_me",
	FilterMaxLength:             "filter_max_length",
	FilterBannedPhrases:         "filter_banned_phrases",
	FilterBannedPhrasesPatterns: "filter_banned_phrases_patterns",
	SubMessage:                  "sub_message",
	SubMessageEnabled:           "sub_message_enabled",
	ResubMessage:                "resub_message",
	ResubMessageEnabled:         "resub_message_enabled",
	LastSeen:                    "last_seen",
	FilterExemptLevel:           "filter_exempt_level",
}

var ChannelTableColumns = struct {
	ID                          string
	CreatedAt                   string
	UpdatedAt                   string
	TwitchID                    string
	Name                        string
	DisplayName                 string
	BotName                     string
	Active                      string
	Prefix                      string
	Bullet                      string
	MessageCount                string
	Mode                        string
	Ignored                     string
	CustomOwners                string
	CustomMods                  string
	CustomRegulars              string
	Cooldown                    string
	LastFM                      string
	ParseYoutube                string
	ExtraLifeID                 string
	RaffleEnabled               string
	SteamID                     string
	UrbanEnabled                string
	Tweet                       string
	RollLevel                   string
	RollCooldown                string
	RollDefault                 string
	ShouldModerate              string
	DisplayWarnings             string
	EnableWarnings              string
	TimeoutDuration             string
	EnableFilters               string
	FilterLinks                 string
	PermittedLinks              string
	SubsMayLink                 string
	FilterCaps                  string
	FilterCapsMinChars          string
	FilterCapsPercentage        string
	FilterCapsMinCaps           string
	FilterEmotes                string
	FilterEmotesMax             string
	FilterEmotesSingle          string
	FilterSymbols               string
	FilterSymbolsPercentage     string
	FilterSymbolsMinSymbols     string
	FilterMe                    string
	FilterMaxLength             string
	FilterBannedPhrases         string
	FilterBannedPhrasesPatterns string
	SubMessage                  string
	SubMessageEnabled           string
	ResubMessage                string
	ResubMessageEnabled         string
	LastSeen                    string
	FilterExemptLevel           string
}{
	ID:                          "channels.id",
	CreatedAt:                   "channels.created_at",
	UpdatedAt:                   "channels.updated_at",
	TwitchID:                    "channels.twitch_id",
	Name:                        "channels.name",
	DisplayName:                 "channels.display_name",
	BotName:                     "channels.bot_name",
	Active:                      "channels.active",
	Prefix:                      "channels.prefix",
	Bullet:                      "channels.bullet",
	MessageCount:                "channels.message_count",
	Mode:                        "channels.mode",
	Ignored:                     "channels.ignored",
	CustomOwners:                "channels.custom_owners",
	CustomMods:                  "channels.custom_mods",
	CustomRegulars:              "channels.custom_regulars",
	Cooldown:                    "channels.cooldown",
	LastFM:                      "channels.last_fm",
	ParseYoutube:                "channels.parse_youtube",
	ExtraLifeID:                 "channels.extra_life_id",
	RaffleEnabled:               "channels.raffle_enabled",
	SteamID:                     "channels.steam_id",
	UrbanEnabled:                "channels.urban_enabled",
	Tweet:                       "channels.tweet",
	RollLevel:                   "channels.roll_level",
	RollCooldown:                "channels.roll_cooldown",
	RollDefault:                 "channels.roll_default",
	ShouldModerate:              "channels.should_moderate",
	DisplayWarnings:             "channels.display_warnings",
	EnableWarnings:              "channels.enable_warnings",
	TimeoutDuration:             "channels.timeout_duration",
	EnableFilters:               "channels.enable_filters",
	FilterLinks:                 "channels.filter_links",
	PermittedLinks:              "channels.permitted_links",
	SubsMayLink:                 "channels.subs_may_link",
	FilterCaps:                  "channels.filter_caps",
	FilterCapsMinChars:          "channels.filter_caps_min_chars",
	FilterCapsPercentage:        "channels.filter_caps_percentage",
	FilterCapsMinCaps:           "channels.filter_caps_min_caps",
	FilterEmotes:                "channels.filter_emotes",
	FilterEmotesMax:             "channels.filter_emotes_max",
	FilterEmotesSingle:          "channels.filter_emotes_single",
	FilterSymbols:               "channels.filter_symbols",
	FilterSymbolsPercentage:     "channels.filter_symbols_percentage",
	FilterSymbolsMinSymbols:     "channels.filter_symbols_min_symbols",
	FilterMe:                    "channels.filter_me",
	FilterMaxLength:             "channels.filter_max_length",
	FilterBannedPhrases:         "channels.filter_banned_phrases",
	FilterBannedPhrasesPatterns: "channels.filter_banned_phrases_patterns",
	SubMessage:                  "channels.sub_message",
	SubMessageEnabled:           "channels.sub_message_enabled",
	ResubMessage:                "channels.resub_message",
	ResubMessageEnabled:         "channels.resub_message_enabled",
	LastSeen:                    "channels.last_seen",
	FilterExemptLevel:           "channels.filter_exempt_level",
}

// Generated where

type whereHelperbool struct{ field string }

func (w whereHelperbool) EQ(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperbool) NEQ(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperbool) LT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperbool) LTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperbool) GT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperbool) GTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

type whereHelpertypes_StringArray struct{ field string }

func (w whereHelpertypes_StringArray) EQ(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertypes_StringArray) NEQ(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertypes_StringArray) LT(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_StringArray) LTE(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_StringArray) GT(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_StringArray) GTE(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_Int struct{ field string }

func (w whereHelpernull_Int) EQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int) NEQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int) LT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int) LTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int) GT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int) GTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Int) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Int) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Int) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var ChannelWhere = struct {
	ID                          whereHelperint64
	CreatedAt                   whereHelpertime_Time
	UpdatedAt                   whereHelpertime_Time
	TwitchID                    whereHelperint64
	Name                        whereHelperstring
	DisplayName                 whereHelperstring
	BotName                     whereHelperstring
	Active                      whereHelperbool
	Prefix                      whereHelperstring
	Bullet                      whereHelpernull_String
	MessageCount                whereHelperint64
	Mode                        whereHelperstring
	Ignored                     whereHelpertypes_StringArray
	CustomOwners                whereHelpertypes_StringArray
	CustomMods                  whereHelpertypes_StringArray
	CustomRegulars              whereHelpertypes_StringArray
	Cooldown                    whereHelpernull_Int
	LastFM                      whereHelperstring
	ParseYoutube                whereHelperbool
	ExtraLifeID                 whereHelperint
	RaffleEnabled               whereHelperbool
	SteamID                     whereHelperstring
	UrbanEnabled                whereHelperbool
	Tweet                       whereHelperstring
	RollLevel                   whereHelperstring
	RollCooldown                whereHelperint
	RollDefault                 whereHelperint
	ShouldModerate              whereHelperbool
	DisplayWarnings             whereHelperbool
	EnableWarnings              whereHelperbool
	TimeoutDuration             whereHelperint
	EnableFilters               whereHelperbool
	FilterLinks                 whereHelperbool
	PermittedLinks              whereHelpertypes_StringArray
	SubsMayLink                 whereHelperbool
	FilterCaps                  whereHelperbool
	FilterCapsMinChars          whereHelperint
	FilterCapsPercentage        whereHelperint
	FilterCapsMinCaps           whereHelperint
	FilterEmotes                whereHelperbool
	FilterEmotesMax             whereHelperint
	FilterEmotesSingle          whereHelperbool
	FilterSymbols               whereHelperbool
	FilterSymbolsPercentage     whereHelperint
	FilterSymbolsMinSymbols     whereHelperint
	FilterMe                    whereHelperbool
	FilterMaxLength             whereHelperint
	FilterBannedPhrases         whereHelperbool
	FilterBannedPhrasesPatterns whereHelpertypes_StringArray
	SubMessage                  whereHelperstring
	SubMessageEnabled           whereHelperbool
	ResubMessage                whereHelperstring
	ResubMessageEnabled         whereHelperbool
	LastSeen                    whereHelpertime_Time
	FilterExemptLevel           whereHelperstring
}{
	ID:                          whereHelperint64{field: "\"channels\".\"id\""},
	CreatedAt:                   whereHelpertime_Time{field: "\"channels\".\"created_at\""},
	UpdatedAt:                   whereHelpertime_Time{field: "\"channels\".\"updated_at\""},
	TwitchID:                    whereHelperint64{field: "\"channels\".\"twitch_id\""},
	Name:                        whereHelperstring{field: "\"channels\".\"name\""},
	DisplayName:                 whereHelperstring{field: "\"channels\".\"display_name\""},
	BotName:                     whereHelperstring{field: "\"channels\".\"bot_name\""},
	Active:                      whereHelperbool{field: "\"channels\".\"active\""},
	Prefix:                      whereHelperstring{field: "\"channels\".\"prefix\""},
	Bullet:                      whereHelpernull_String{field: "\"channels\".\"bullet\""},
	MessageCount:                whereHelperint64{field: "\"channels\".\"message_count\""},
	Mode:                        whereHelperstring{field: "\"channels\".\"mode\""},
	Ignored:                     whereHelpertypes_StringArray{field: "\"channels\".\"ignored\""},
	CustomOwners:                whereHelpertypes_StringArray{field: "\"channels\".\"custom_owners\""},
	CustomMods:                  whereHelpertypes_StringArray{field: "\"channels\".\"custom_mods\""},
	CustomRegulars:              whereHelpertypes_StringArray{field: "\"channels\".\"custom_regulars\""},
	Cooldown:                    whereHelpernull_Int{field: "\"channels\".\"cooldown\""},
	LastFM:                      whereHelperstring{field: "\"channels\".\"last_fm\""},
	ParseYoutube:                whereHelperbool{field: "\"channels\".\"parse_youtube\""},
	ExtraLifeID:                 whereHelperint{field: "\"channels\".\"extra_life_id\""},
	RaffleEnabled:               whereHelperbool{field: "\"channels\".\"raffle_enabled\""},
	SteamID:                     whereHelperstring{field: "\"channels\".\"steam_id\""},
	UrbanEnabled:                whereHelperbool{field: "\"channels\".\"urban_enabled\""},
	Tweet:                       whereHelperstring{field: "\"channels\".\"tweet\""},
	RollLevel:                   whereHelperstring{field: "\"channels\".\"roll_level\""},
	RollCooldown:                whereHelperint{field: "\"channels\".\"roll_cooldown\""},
	RollDefault:                 whereHelperint{field: "\"channels\".\"roll_default\""},
	ShouldModerate:              whereHelperbool{field: "\"channels\".\"should_moderate\""},
	DisplayWarnings:             whereHelperbool{field: "\"channels\".\"display_warnings\""},
	EnableWarnings:              whereHelperbool{field: "\"channels\".\"enable_warnings\""},
	TimeoutDuration:             whereHelperint{field: "\"channels\".\"timeout_duration\""},
	EnableFilters:               whereHelperbool{field: "\"channels\".\"enable_filters\""},
	FilterLinks:                 whereHelperbool{field: "\"channels\".\"filter_links\""},
	PermittedLinks:              whereHelpertypes_StringArray{field: "\"channels\".\"permitted_links\""},
	SubsMayLink:                 whereHelperbool{field: "\"channels\".\"subs_may_link\""},
	FilterCaps:                  whereHelperbool{field: "\"channels\".\"filter_caps\""},
	FilterCapsMinChars:          whereHelperint{field: "\"channels\".\"filter_caps_min_chars\""},
	FilterCapsPercentage:        whereHelperint{field: "\"channels\".\"filter_caps_percentage\""},
	FilterCapsMinCaps:           whereHelperint{field: "\"channels\".\"filter_caps_min_caps\""},
	FilterEmotes:                whereHelperbool{field: "\"channels\".\"filter_emotes\""},
	FilterEmotesMax:             whereHelperint{field: "\"channels\".\"filter_emotes_max\""},
	FilterEmotesSingle:          whereHelperbool{field: "\"channels\".\"filter_emotes_single\""},
	FilterSymbols:               whereHelperbool{field: "\"channels\".\"filter_symbols\""},
	FilterSymbolsPercentage:     whereHelperint{field: "\"channels\".\"filter_symbols_percentage\""},
	FilterSymbolsMinSymbols:     whereHelperint{field: "\"channels\".\"filter_symbols_min_symbols\""},
	FilterMe:                    whereHelperbool{field: "\"channels\".\"filter_me\""},
	FilterMaxLength:             whereHelperint{field: "\"channels\".\"filter_max_length\""},
	FilterBannedPhrases:         whereHelperbool{field: "\"channels\".\"filter_banned_phrases\""},
	FilterBannedPhrasesPatterns: whereHelpertypes_StringArray{field: "\"channels\".\"filter_banned_phrases_patterns\""},
	SubMessage:                  whereHelperstring{field: "\"channels\".\"sub_message\""},
	SubMessageEnabled:           whereHelperbool{field: "\"channels\".\"sub_message_enabled\""},
	ResubMessage:                whereHelperstring{field: "\"channels\".\"resub_message\""},
	ResubMessageEnabled:         whereHelperbool{field: "\"channels\".\"resub_message_enabled\""},
	LastSeen:                    whereHelpertime_Time{field: "\"channels\".\"last_seen\""},
	FilterExemptLevel:           whereHelperstring{field: "\"channels\".\"filter_exempt_level\""},
}

// ChannelRels is where relationship names are stored.
var ChannelRels = struct {
	Autoreplies       string
	CommandInfos      string
	CommandLists      string
	CustomCommands    string
	Highlights        string
	Quotes            string
	RepeatedCommands  string
	ScheduledCommands string
	Variables         string
}{
	Autoreplies:       "Autoreplies",
	CommandInfos:      "CommandInfos",
	CommandLists:      "CommandLists",
	CustomCommands:    "CustomCommands",
	Highlights:        "Highlights",
	Quotes:            "Quotes",
	RepeatedCommands:  "RepeatedCommands",
	ScheduledCommands: "ScheduledCommands",
	Variables:         "Variables",
}

// channelR is where relationships are stored.
type channelR struct {
	Autoreplies       AutoreplySlice        `boil:"Autoreplies" json:"Autoreplies" toml:"Autoreplies" yaml:"Autoreplies"`
	CommandInfos      CommandInfoSlice      `boil:"CommandInfos" json:"CommandInfos" toml:"CommandInfos" yaml:"CommandInfos"`
	CommandLists      CommandListSlice      `boil:"CommandLists" json:"CommandLists" toml:"CommandLists" yaml:"CommandLists"`
	CustomCommands    CustomCommandSlice    `boil:"CustomCommands" json:"CustomCommands" toml:"CustomCommands" yaml:"CustomCommands"`
	Highlights        HighlightSlice        `boil:"Highlights" json:"Highlights" toml:"Highlights" yaml:"Highlights"`
	Quotes            QuoteSlice            `boil:"Quotes" json:"Quotes" toml:"Quotes" yaml:"Quotes"`
	RepeatedCommands  RepeatedCommandSlice  `boil:"RepeatedCommands" json:"RepeatedCommands" toml:"RepeatedCommands" yaml:"RepeatedCommands"`
	ScheduledCommands ScheduledCommandSlice `boil:"ScheduledCommands" json:"ScheduledCommands" toml:"ScheduledCommands" yaml:"ScheduledCommands"`
	Variables         VariableSlice         `boil:"Variables" json:"Variables" toml:"Variables" yaml:"Variables"`
}

// NewStruct creates a new relationship struct
func (*channelR) NewStruct() *channelR {
	return &channelR{}
}

func (r *channelR) GetAutoreplies() AutoreplySlice {
	if r == nil {
		return nil
	}
	return r.Autoreplies
}

func (r *channelR) GetCommandInfos() CommandInfoSlice {
	if r == nil {
		return nil
	}
	return r.CommandInfos
}

func (r *channelR) GetCommandLists() CommandListSlice {
	if r == nil {
		return nil
	}
	return r.CommandLists
}

func (r *channelR) GetCustomCommands() CustomCommandSlice {
	if r == nil {
		return nil
	}
	return r.CustomCommands
}

func (r *channelR) GetHighlights() HighlightSlice {
	if r == nil {
		return nil
	}
	return r.Highlights
}

func (r *channelR) GetQuotes() QuoteSlice {
	if r == nil {
		return nil
	}
	return r.Quotes
}

func (r *channelR) GetRepeatedCommands() RepeatedCommandSlice {
	if r == nil {
		return nil
	}
	return r.RepeatedCommands
}

func (r *channelR) GetScheduledCommands() ScheduledCommandSlice {
	if r == nil {
		return nil
	}
	return r.ScheduledCommands
}

func (r *channelR) GetVariables() VariableSlice {
	if r == nil {
		return nil
	}
	return r.Variables
}

// channelL is where Load methods for each relationship are stored.
type channelL struct{}

var (
	channelAllColumns            = []string{"id", "created_at", "updated_at", "twitch_id", "name", "display_name", "bot_name", "active", "prefix", "bullet", "message_count", "mode", "ignored", "custom_owners", "custom_mods", "custom_regulars", "cooldown", "last_fm", "parse_youtube", "extra_life_id", "raffle_enabled", "steam_id", "urban_enabled", "tweet", "roll_level", "roll_cooldown", "roll_default", "should_moderate", "display_warnings", "enable_warnings", "timeout_duration", "enable_filters", "filter_links", "permitted_links", "subs_may_link", "filter_caps", "filter_caps_min_chars", "filter_caps_percentage", "filter_caps_min_caps", "filter_emotes", "filter_emotes_max", "filter_emotes_single", "filter_symbols", "filter_symbols_percentage", "filter_symbols_min_symbols", "filter_me", "filter_max_length", "filter_banned_phrases", "filter_banned_phrases_patterns", "sub_message", "sub_message_enabled", "resub_message", "resub_message_enabled", "last_seen", "filter_exempt_level"}
	channelColumnsWithoutDefault = []string{"twitch_id", "name", "display_name", "bot_name", "active", "prefix", "message_count", "mode", "last_fm", "parse_youtube", "extra_life_id", "raffle_enabled", "steam_id", "urban_enabled", "tweet", "roll_level", "roll_cooldown", "roll_default", "should_moderate", "display_warnings", "enable_warnings", "timeout_duration", "enable_filters", "filter_links", "subs_may_link", "filter_caps", "filter_caps_min_chars", "filter_caps_percentage", "filter_caps_min_caps", "filter_emotes", "filter_emotes_max", "filter_emotes_single", "filter_symbols", "filter_symbols_percentage", "filter_symbols_min_symbols", "filter_me", "filter_max_length", "filter_banned_phrases", "sub_message", "sub_message_enabled", "resub_message", "resub_message_enabled", "filter_exempt_level"}
	channelColumnsWithDefault    = []string{"id", "created_at", "updated_at", "bullet", "ignored", "custom_owners", "custom_mods", "custom_regulars", "cooldown", "permitted_links", "filter_banned_phrases_patterns", "last_seen"}
	channelPrimaryKeyColumns     = []string{"id"}
	channelGeneratedColumns      = []string{}
)

type (
	// ChannelSlice is an alias for a slice of pointers to Channel.
	// This should almost always be used instead of []Channel.
	ChannelSlice []*Channel

	channelQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	channelType                 = reflect.TypeOf(&Channel{})
	channelMapping              = queries.MakeStructMapping(channelType)
	channelPrimaryKeyMapping, _ = queries.BindMapping(channelType, channelMapping, channelPrimaryKeyColumns)
	channelInsertCacheMut       sync.RWMutex
	channelInsertCache          = make(map[string]insertCache)
	channelUpdateCacheMut       sync.RWMutex
	channelUpdateCache          = make(map[string]updateCache)
	channelUpsertCacheMut       sync.RWMutex
	channelUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single channel record from the query.
func (q channelQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Channel, error) {
	o := &Channel{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for channels")
	}

	return o, nil
}

// All returns all Channel records from the query.
func (q channelQuery) All(ctx context.Context, exec boil.ContextExecutor) (ChannelSlice, error) {
	var o []*Channel

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Channel slice")
	}

	return o, nil
}

// Count returns the count of all Channel records in the query.
func (q channelQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count channels rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q channelQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if channels exists")
	}

	return count > 0, nil
}

// Autoreplies retrieves all the autoreply's Autoreplies with an executor.
func (o *Channel) Autoreplies(mods ...qm.QueryMod) autoreplyQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"autoreplies\".\"channel_id\"=?", o.ID),
	)

	return Autoreplies(queryMods...)
}

// CommandInfos retrieves all the command_info's CommandInfos with an executor.
func (o *Channel) CommandInfos(mods ...qm.QueryMod) commandInfoQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"command_infos\".\"channel_id\"=?", o.ID),
	)

	return CommandInfos(queryMods...)
}

// CommandLists retrieves all the command_list's CommandLists with an executor.
func (o *Channel) CommandLists(mods ...qm.QueryMod) commandListQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"command_lists\".\"channel_id\"=?", o.ID),
	)

	return CommandLists(queryMods...)
}

// CustomCommands retrieves all the custom_command's CustomCommands with an executor.
func (o *Channel) CustomCommands(mods ...qm.QueryMod) customCommandQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"custom_commands\".\"channel_id\"=?", o.ID),
	)

	return CustomCommands(queryMods...)
}

// Highlights retrieves all the highlight's Highlights with an executor.
func (o *Channel) Highlights(mods ...qm.QueryMod) highlightQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"highlights\".\"channel_id\"=?", o.ID),
	)

	return Highlights(queryMods...)
}

// Quotes retrieves all the quote's Quotes with an executor.
func (o *Channel) Quotes(mods ...qm.QueryMod) quoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"quotes\".\"channel_id\"=?", o.ID),
	)

	return Quotes(queryMods...)
}

// RepeatedCommands retrieves all the repeated_command's RepeatedCommands with an executor.
func (o *Channel) RepeatedCommands(mods ...qm.QueryMod) repeatedCommandQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"repeated_commands\".\"channel_id\"=?", o.ID),
	)

	return RepeatedCommands(queryMods...)
}

// ScheduledCommands retrieves all the scheduled_command's ScheduledCommands with an executor.
func (o *Channel) ScheduledCommands(mods ...qm.QueryMod) scheduledCommandQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"scheduled_commands\".\"channel_id\"=?", o.ID),
	)

	return ScheduledCommands(queryMods...)
}

// Variables retrieves all the variable's Variables with an executor.
func (o *Channel) Variables(mods ...qm.QueryMod) variableQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"variables\".\"channel_id\"=?", o.ID),
	)

	return Variables(queryMods...)
}

// LoadAutoreplies allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadAutoreplies(ctx context.Context, e boil.ContextExecutor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		var ok bool
		object, ok = maybeChannel.(*Channel)
		if !ok {
			object = new(Channel)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeChannel))
			}
		}
	} else {
		s, ok := maybeChannel.(*[]*Channel)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeChannel))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`autoreplies`),
		qm.WhereIn(`autoreplies.channel_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load autoreplies")
	}

	var resultSlice []*Autoreply
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice autoreplies")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on autoreplies")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for autoreplies")
	}

	if singular {
		object.R.Autoreplies = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &autoreplyR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.Autoreplies = append(local.R.Autoreplies, foreign)
				if foreign.R == nil {
					foreign.R = &autoreplyR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadCommandInfos allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadCommandInfos(ctx context.Context, e boil.ContextExecutor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		var ok bool
		object, ok = maybeChannel.(*Channel)
		if !ok {
			object = new(Channel)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeChannel))
			}
		}
	} else {
		s, ok := maybeChannel.(*[]*Channel)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeChannel))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`command_infos`),
		qm.WhereIn(`command_infos.channel_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load command_infos")
	}

	var resultSlice []*CommandInfo
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice command_infos")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on command_infos")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for command_infos")
	}

	if singular {
		object.R.CommandInfos = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &commandInfoR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.CommandInfos = append(local.R.CommandInfos, foreign)
				if foreign.R == nil {
					foreign.R = &commandInfoR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadCommandLists allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadCommandLists(ctx context.Context, e boil.ContextExecutor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		var ok bool
		object, ok = maybeChannel.(*Channel)
		if !ok {
			object = new(Channel)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeChannel))
			}
		}
	} else {
		s, ok := maybeChannel.(*[]*Channel)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeChannel))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`command_lists`),
		qm.WhereIn(`command_lists.channel_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load command_lists")
	}

	var resultSlice []*CommandList
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice command_lists")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on command_lists")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for command_lists")
	}

	if singular {
		object.R.CommandLists = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &commandListR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.CommandLists = append(local.R.CommandLists, foreign)
				if foreign.R == nil {
					foreign.R = &commandListR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadCustomCommands allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadCustomCommands(ctx context.Context, e boil.ContextExecutor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		var ok bool
		object, ok = maybeChannel.(*Channel)
		if !ok {
			object = new(Channel)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeChannel))
			}
		}
	} else {
		s, ok := maybeChannel.(*[]*Channel)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeChannel))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`custom_commands`),
		qm.WhereIn(`custom_commands.channel_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load custom_commands")
	}

	var resultSlice []*CustomCommand
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice custom_commands")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on custom_commands")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for custom_commands")
	}

	if singular {
		object.R.CustomCommands = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &customCommandR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.CustomCommands = append(local.R.CustomCommands, foreign)
				if foreign.R == nil {
					foreign.R = &customCommandR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadHighlights allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadHighlights(ctx context.Context, e boil.ContextExecutor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		var ok bool
		object, ok = maybeChannel.(*Channel)
		if !ok {
			object = new(Channel)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeChannel))
			}
		}
	} else {
		s, ok := maybeChannel.(*[]*Channel)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeChannel))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`highlights`),
		qm.WhereIn(`highlights.channel_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load highlights")
	}

	var resultSlice []*Highlight
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice highlights")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on highlights")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for highlights")
	}

	if singular {
		object.R.Highlights = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &highlightR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.Highlights = append(local.R.Highlights, foreign)
				if foreign.R == nil {
					foreign.R = &highlightR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadQuotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadQuotes(ctx context.Context, e boil.ContextExecutor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		var ok bool
		object, ok = maybeChannel.(*Channel)
		if !ok {
			object = new(Channel)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeChannel))
			}
		}
	} else {
		s, ok := maybeChannel.(*[]*Channel)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeChannel))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`quotes`),
		qm.WhereIn(`quotes.channel_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load quotes")
	}

	var resultSlice []*Quote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice quotes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on quotes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for quotes")
	}

	if singular {
		object.R.Quotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &quoteR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.Quotes = append(local.R.Quotes, foreign)
				if foreign.R == nil {
					foreign.R = &quoteR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadRepeatedCommands allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadRepeatedCommands(ctx context.Context, e boil.ContextExecutor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		var ok bool
		object, ok = maybeChannel.(*Channel)
		if !ok {
			object = new(Channel)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeChannel))
			}
		}
	} else {
		s, ok := maybeChannel.(*[]*Channel)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeChannel))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`repeated_commands`),
		qm.WhereIn(`repeated_commands.channel_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load repeated_commands")
	}

	var resultSlice []*RepeatedCommand
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice repeated_commands")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on repeated_commands")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for repeated_commands")
	}

	if singular {
		object.R.RepeatedCommands = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &repeatedCommandR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.RepeatedCommands = append(local.R.RepeatedCommands, foreign)
				if foreign.R == nil {
					foreign.R = &repeatedCommandR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadScheduledCommands allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadScheduledCommands(ctx context.Context, e boil.ContextExecutor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		var ok bool
		object, ok = maybeChannel.(*Channel)
		if !ok {
			object = new(Channel)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeChannel))
			}
		}
	} else {
		s, ok := maybeChannel.(*[]*Channel)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeChannel))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`scheduled_commands`),
		qm.WhereIn(`scheduled_commands.channel_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load scheduled_commands")
	}

	var resultSlice []*ScheduledCommand
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice scheduled_commands")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on scheduled_commands")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for scheduled_commands")
	}

	if singular {
		object.R.ScheduledCommands = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &scheduledCommandR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.ScheduledCommands = append(local.R.ScheduledCommands, foreign)
				if foreign.R == nil {
					foreign.R = &scheduledCommandR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadVariables allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadVariables(ctx context.Context, e boil.ContextExecutor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		var ok bool
		object, ok = maybeChannel.(*Channel)
		if !ok {
			object = new(Channel)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeChannel))
			}
		}
	} else {
		s, ok := maybeChannel.(*[]*Channel)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeChannel))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`variables`),
		qm.WhereIn(`variables.channel_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load variables")
	}

	var resultSlice []*Variable
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice variables")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on variables")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for variables")
	}

	if singular {
		object.R.Variables = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &variableR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.Variables = append(local.R.Variables, foreign)
				if foreign.R == nil {
					foreign.R = &variableR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// AddAutoreplies adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.Autoreplies.
// Sets related.R.Channel appropriately.
func (o *Channel) AddAutoreplies(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Autoreply) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"autoreplies\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, autoreplyPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			Autoreplies: related,
		}
	} else {
		o.R.Autoreplies = append(o.R.Autoreplies, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &autoreplyR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddCommandInfos adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.CommandInfos.
// Sets related.R.Channel appropriately.
func (o *Channel) AddCommandInfos(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CommandInfo) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"command_infos\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, commandInfoPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			CommandInfos: related,
		}
	} else {
		o.R.CommandInfos = append(o.R.CommandInfos, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &commandInfoR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddCommandLists adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.CommandLists.
// Sets related.R.Channel appropriately.
func (o *Channel) AddCommandLists(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CommandList) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"command_lists\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, commandListPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			CommandLists: related,
		}
	} else {
		o.R.CommandLists = append(o.R.CommandLists, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &commandListR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddCustomCommands adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.CustomCommands.
// Sets related.R.Channel appropriately.
func (o *Channel) AddCustomCommands(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CustomCommand) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"custom_commands\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, customCommandPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			CustomCommands: related,
		}
	} else {
		o.R.CustomCommands = append(o.R.CustomCommands, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &customCommandR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddHighlights adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.Highlights.
// Sets related.R.Channel appropriately.
func (o *Channel) AddHighlights(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Highlight) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"highlights\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, highlightPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			Highlights: related,
		}
	} else {
		o.R.Highlights = append(o.R.Highlights, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &highlightR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddQuotes adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.Quotes.
// Sets related.R.Channel appropriately.
func (o *Channel) AddQuotes(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Quote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"quotes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, quotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			Quotes: related,
		}
	} else {
		o.R.Quotes = append(o.R.Quotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &quoteR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddRepeatedCommands adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.RepeatedCommands.
// Sets related.R.Channel appropriately.
func (o *Channel) AddRepeatedCommands(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*RepeatedCommand) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"repeated_commands\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, repeatedCommandPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			RepeatedCommands: related,
		}
	} else {
		o.R.RepeatedCommands = append(o.R.RepeatedCommands, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &repeatedCommandR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddScheduledCommands adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.ScheduledCommands.
// Sets related.R.Channel appropriately.
func (o *Channel) AddScheduledCommands(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ScheduledCommand) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"scheduled_commands\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, scheduledCommandPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			ScheduledCommands: related,
		}
	} else {
		o.R.ScheduledCommands = append(o.R.ScheduledCommands, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &scheduledCommandR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddVariables adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.Variables.
// Sets related.R.Channel appropriately.
func (o *Channel) AddVariables(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Variable) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"variables\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, variablePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			Variables: related,
		}
	} else {
		o.R.Variables = append(o.R.Variables, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &variableR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// Channels retrieves all the records using an executor.
func Channels(mods ...qm.QueryMod) channelQuery {
	mods = append(mods, qm.From("\"channels\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"channels\".*"})
	}

	return channelQuery{q}
}

// FindChannel retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindChannel(ctx context.Context, exec boil.ContextExecutor, iD int64, selectCols ...string) (*Channel, error) {
	channelObj := &Channel{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"channels\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, channelObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from channels")
	}

	return channelObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Channel) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no channels provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	nzDefaults := queries.NonZeroDefaultSet(channelColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	channelInsertCacheMut.RLock()
	cache, cached := channelInsertCache[key]
	channelInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			channelAllColumns,
			channelColumnsWithDefault,
			channelColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(channelType, channelMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(channelType, channelMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"channels\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"channels\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into channels")
	}

	if !cached {
		channelInsertCacheMut.Lock()
		channelInsertCache[key] = cache
		channelInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the Channel.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Channel) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	key := makeCacheKey(columns, nil)
	channelUpdateCacheMut.RLock()
	cache, cached := channelUpdateCache[key]
	channelUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			channelAllColumns,
			channelPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return errors.New("models: unable to update channels, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"channels\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, channelPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(channelType, channelMapping, append(wl, channelPrimaryKeyColumns...))
		if err != nil {
			return err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	_, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update channels row")
	}

	if !cached {
		channelUpdateCacheMut.Lock()
		channelUpdateCache[key] = cache
		channelUpdateCacheMut.Unlock()
	}

	return nil
}

// UpdateAll updates all rows with the specified column values.
func (q channelQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	queries.SetUpdate(q.Query, cols)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all for channels")
	}

	return nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o ChannelSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	ln := int64(len(o))
	if ln == 0 {
		return nil
	}

	if len(cols) == 0 {
		return errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), channelPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"channels\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, channelPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all in channel slice")
	}

	return nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Channel) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no channels provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	nzDefaults := queries.NonZeroDefaultSet(channelColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	channelUpsertCacheMut.RLock()
	cache, cached := channelUpsertCache[key]
	channelUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			channelAllColumns,
			channelColumnsWithDefault,
			channelColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			channelAllColumns,
			channelPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert channels, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(channelPrimaryKeyColumns))
			copy(conflict, channelPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"channels\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(channelType, channelMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(channelType, channelMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert channels")
	}

	if !cached {
		channelUpsertCacheMut.Lock()
		channelUpsertCache[key] = cache
		channelUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single Channel record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Channel) Delete(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil {
		return errors.New("models: no Channel provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), channelPrimaryKeyMapping)
	sql := "DELETE FROM \"channels\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete from channels")
	}

	return nil
}

// DeleteAll deletes all matching rows.
func (q channelQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if q.Query == nil {
		return errors.New("models: no channelQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from channels")
	}

	return nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o ChannelSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if len(o) == 0 {
		return nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), channelPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"channels\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, channelPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from channel slice")
	}

	return nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Channel) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindChannel(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ChannelSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ChannelSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), channelPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"channels\".* FROM \"channels\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, channelPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in ChannelSlice")
	}

	*o = slice

	return nil
}

// ChannelExists checks if the Channel row exists.
func ChannelExists(ctx context.Context, exec boil.ContextExecutor, iD int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"channels\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if channels exists")
	}

	return exists, nil
}
